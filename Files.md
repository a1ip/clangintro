##Файлы

Файлом называют способ хранения информации на физическом устройстве. Файл - это понятие, которое применимо ко всему - от файла на диске до терминала.

В языке Си отсутствуют операторы для работы с файлами. Все необходимые действия выполняются с помощью функций, включенных в стандартную библиотеку. Они позволяют работать с различными устройствами, такими, как диски, принтер, коммуникационные каналы и т.д. Эти устройства сильно отличаются друг от друга. Однако файловая система преобразует их в единое _абстрактное логическое устройство_, называемое _потоком_.

В Си существует два типа потоков: текстовые (`text`) и двоичные (`binary`).

_Текстовый поток_ - это последовательность символов. При передаче символов из потока на экран, часть из них не выводится (например, символ возврата каретки, перевода строки).

_Двоичный поток_ - это последовательность байтов, которые однозначно соответствуют тому, что находится на внешнем устройстве.

Прежде чем читать или записывать информацию в файл, он должен быть открыт и тем самым связан с потоком. Это можно сделать с помощью библиотечной функции `fopen( )`. Она берет внешнее представление файла (например, `c:\my_prog.txt`) и связывает его с внутренним логическим именем, которое используется далее в программе. Логическое имя - это указатель на требуемый файл. Его необходимо определить; делается это, например, так:

```c
FILE *fp;
```

Здесь `FILE` - имя типа, описанное в стандартном заголовочном файле `stdio.h`, `fp` - указатель на файл. Обращение к функции `fopen( )` в программе осуществляется выражением:

```c
fp = fopen(спецификация файла, "способ использования файла");
```

Спецификация файла (т.е. имя файла и путь к нему) может, например, иметь вид: `"c:\\my_prog.txt"` - для файла `my_prog.txt` на диске `с:`.

Способ использования файла задается следующими символами:

*   `r` - открыть существующий файл для чтения;
*   `w` - создать новый файл для записи (если файл с указанным именем существует, то он будет переписан);
*   `а` - дополнить файл (открыть существующий файл для записи информации, начиная с конца файла, или создать файл, если он не существует);

*   `r+` - открыть существующий файл для чтения и записи;
*   `w+` - создать новый файл для чтения и записи;
*   `a+` - дополнить или создать файл с возможностью чтения и записи;

*   `rb` - открыть двоичный файл для чтения;
*   `w`b - создать двоичный файл для записи;
*   `аb` - дополнить двоичный файл;

*   `r+b` - открыть двоичный файл для чтения и записи;
*   `w+b` - создать двоичный файл для чтения и записи;
*   `а+b` - дополнить двоичный файл с предоставлением возможности чтения и записи;

*   `rt` - открыть текстовой файл для чтения;
*   `wt` - создать текстовый файл для записи;
*   `at` - дополнить текстовый файл;

*   `r+t` - открыть текстовой файл для чтения и записи;
*   `w+t` - создать текстовый файл для чтения и записи;
*   `a+t` - дополнить текстовый файл с предоставлением возможности записи и чтения.

Если режим `t` или `b` не задан (например, `r`, `w` или `а`), то он определяется значением глобальной переменной `_fmode`. Если `_fmode=0_BINARY`, то файлы открываются в двоичном режиме, а если `_fmode=0_TEXT` - в текстовом режиме. Константы `0_BINARY` и `0_ТЕXТ` определены в файле `fcntl.h`.

Строки вида `r+b` можно записывать и в другой форме: `rb+`.

Если в результате обращения к функции `fopen( )` возникает ошибка, то она возвращает константу `NULL`.

Рекомендуется использовать следующий способ открытия файла:

```c
if ((fp = fopen("c:\\my_prog.txt", "rt")) == NULL)
{
     puts("Открыть файл не удалось\n");
     exit(1);
}
```

После окончания работы с файлом он должен быть закрыт. Это делается с помощью библиотечной функции `fclose( )`. Она имеет следующий прототип:

```c
int fclose(FILE *fp);
```

При успешном завершении операции функция `fclose( )` возвращает значение нуль. Любое другое значение свидетельствует об ошибке.

Рассмотрим другие библиотечные функции, используемые для работы с файлами (все они описаны в файле `stdio.h`):

1. Функция putc( ) записывает символ в файл и имеет следующий прототип:

  ```c
  int putc(int с, FILE *fp);
  ```

  Здесь `fp` - указатель на файл, возвращенный функцией `fopen( )`, `с` - символ для записи (переменная с имеет тип `int`, но используется только младший байт). При успешном завершении `putc( )` возвращает записанный символ, в противном случае возвращается константа `EOF`. Она определена в файле `stdio.h` и имеет значение `-1`\.

2. Функция `getc( )` читает символ из файла и имеет следующий прототип:

  ```c
  int getc(FILE *fp);
  ```

  Здесь `fp` - указатель на файл, возвращенный функцией `fopen( )`. Эта функция возвращает прочитанный символ. Соответствующее значение имеет тип int, но старший байт равен нулю. Если достигнут конец файла, то `getc( )` возвращает значение `ЕОF`.

3. Функция `feof( )` определяет конец файла при чтении двоичных данных и имеет следующий прототип:

  ```c
  int feof(FILE *fp);
  ```

  Здесь `fp` - указатель на файл, возвращенный функцией `fopen( )`. При достижении конца файла возвращается ненулевое значение, в противном случае возвращается `0`\.

4. Функция `fputs( )` записывает строку символов в файл. Она отличается от функции `puts( )` только тем, что в качестве второго параметра должен быть записан указатель на переменную файлового типа.

  Например:

  ```c
  fputs("Ехаmple", fp);
  ```

  При возникновении ошибки возвращается значение `EOF`.

5. Функция `fgets( )` читает строку символов из файла. Она отличается от функции `gets( )` тем, что в качестве второго параметра должно быть указано максимальное число вводимых символов плюс единица, а в качестве третьего - указатель на переменную файлового типа. Строка считывается целиком, если ее длина не превышает указанного числа символов, в противном случае функция возвращает только заданное число символов.

  Рассмотрим пример:

  ```c
  fgets(string, n, fp);
  ```

  Функция возвращает указатель на строку `string` при успешном завершении и константу `NULL` в случае ошибки либо достижения конца файла.

6. Функция `fprintf( )` выполняет те же действия, что и функция `printf( )`, но работает с файлом. Ее отличием является то, что в качестве первого параметра задается указатель на переменную файлового типа.

  Например:

  ```c
  fprintf(fp, "%х",а);
  ```

7. Функция `fscanf( )` выполняет те же действия, что и функция `scanf()`, но работает с файлом. Ее отличием является то, что в качестве первого параметра задается указатель на переменную файлового типа.

  Например:

  ```c
  fscanf(fp, "%х", &a);
  ```

  При достижении конца файла возвращается значение `EOF`.

8. Функция `fseek( )` позволяет выполнять чтение и запись с произвольным доступом и имеет следующий прототип:

  ```c
  int fseek(FILE *fp, long count, int access);
  ```

  Здесь `fp` - указатель на файл, возвращенный функцией `fopen( )`, `count` - номер байта относительно заданной начальной позиции, начиная с которого будет выполняться операция, `access` - способ задания начальной позиции.

  Переменная `access` может принимать следующие значения:

  При успешном завершении возвращается нуль, при ошибке - ненулевое значение.

9. Функция `ferror( )` позволяет проверить правильность выполнения последней операции при работе с файлами. Имеет следующий прототип:

  ```c
  int ferror(FILE *fp);
  ```

  В случае ошибки возвращается ненулевое значение, в противном случае возвращается нуль.

10. Функция `remove( )` удаляет файл и имеет следующий прототип:

  ```c
  int remove(char *file_name);
  ```

  Здесь `file_name` - указатель на строку со спецификацией файла. При успешном завершении возвращается нуль, в противном случае возвращается ненулевое значение.

11. Функция `rewind( )` устанавливает указатель текущей позиции в начало файла и имеет следующий прототип:

  ```c
  void rewind(FILE *fp);
  ```

12. Функция `fread( )` предназначена для чтения блоков данных из потока. Имеет прототип:

  ```c
  unsigned fread(void *ptr, unsigned size, unsigned n, FILE *fp);
  ```

  Она читает n элементов данных, длиной `size` байт каждый, из заданного входного потока `fp` в блок, на который указывает указатель `ptr`. Общее число прочитанных байтов равно произведению `n*size`. При успешном завершении функция `fread( )` возвращает число прочитанных элементов данных, при ошибке - `0`.

13. Функция `fwrite( )` предназначена для записи в файл блоков данных. Имеет прототип:

  ```c
  unsigned fwrite(void *ptr, unsigned size, unsigned n, FILE *fp);
  ```

  Она добавляет `n` элементов данных, длиной `size` байт каждый, в заданный выходной файл `fp`. Данные записываются с позиции, на которую указывает указатель `ptr`. При успешном завершении операции функция `fwrite( )` возвращает число записанных элементов данных, при ошибке - неверное число элементов данных.

В языке Си имеются пять стандартных файлов со следующими логическими именами:

*   `stdin` - для ввода данных из стандартного входного потока (по умолчанию - c клавиатуры);
*   `stdout` - для вывода данных в стандартный выходной поток (по умолчанию - на экран дисплея);
*   `stderr` - файл для вывода сообщений об ошибках (всегда связан с экраном дисплея);
*   `stdprn` - для вывода данных на принтер;
*   `stdaus` - для ввода и вывода данных в коммуникационный канал.

В языке Си имеется также система низкоуровневого ввода/вывода (без буферизации и форматирования данных), соответствующая стандарту системы UNIX. Прототипы составляющих ее функций находятся в файле `io.h`. К этим функциям относятся:

*   `open( )` - открыть файл;
*   `close( )` - закрыть файл;
*   `read( )` - читать данные;
*   `write( )` - записать данные;
*   `lseek( )` - поиск определенного байта в файле;
*   `unlink( )` - уничтожить файл.
