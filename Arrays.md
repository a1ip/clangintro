##СТРУКТУРИРОВАННЫЕ ТИПЫ ДАННЫХ

###Массивы

Массив состоит из элементов одного и того же типа. Ко всему массиву целиком можно обращаться по имени. Кроме того, можно выбирать любой элемент массива. Для этого необходимо задать индекс, который указывает на его относительную позицию. Число элементов массива назначается при его определении и в дальнейшем не изменяется. Если массив объявлен, то к любому его элементу можно обратиться следующим образом: указать имя массива и индекс элемента в квадратных скобках. Массивы определяются так же, как и переменные:

```c
int a[100];
char b[20];
float d[50];
```

В первой строке объявлен массив `а` из `100` элементов целого типа: `а[0]`, `а[1]`, ..., `а[99]` (индексация всегда начинается с нуля). Во второй строке элементы массива `b` имеют тип `char`, а в третьей - `float`.

Двумерный массив представляется как одномерный, элементами которого так же являются массивы. Например, определение `char а[10][20]`; задает такой массив. По аналогии можно установить и большее число измерений. Элементы двумерного массива хранятся по строкам, т.е. если проходить по ним в порядке их расположения в памяти, то быстрее всего изменяется самый правый индекс. Например, обращение к девятому элементу пятой строки запишется так: `а[5][9]`.

Пусть задан массив:

```c
int a[2][3];
```

Тогда элементы массива а будут размещаться в памяти следующим образом: `a[0][0]`, `a[0][1]`, `a[0][2]`, `a[1][0]`, `a[1][1]`, `a[1][2]`.

Имя массива - это константа, которая содержит адрес его первого элемента (в данном примере `а` содержит адрес элемента `а[0][0]`). Предположим, что `a = 1000`\. Тогда адрес элемента `а[0][1]` будет равен `1002` (элемент типа `int` занимает в памяти 2 байта), адрес следующего элемента `а[0][2]` - `1004` и т.д. Что же произойдет, если выбрать элемент, для которого не выделена память? К сожалению, компилятор не отслеживает данной ситуации. В результате возникнет ошибка и программа будет работать неправильно.

В языке Си существует сильная взаимосвязь между указателями и массивами. Любое действие, которое достигается индексированием массива, можно выполнить и с помощью указателей, причем последний вариант будет работать быстрее.

Определение

```c
int a[5];
```

задает массив из пяти элементов `а[0]`, `a[1]`, `a[2]`, `a[3]`, `a[4]`. Если объект `*у` определен как

```c
int *у;
```

то оператор `у = &a[0]`; присваивает переменной у адрес элемента `а[0]`. Если переменная `у` указывает на очередной элемент массива `а`, то `y+1` указывает на следующий элемент, причем здесь выполняется соответствующее масштабирование для приращения адреса с учетом длины объекта (для типа `int` - 2 байта, `long` - 4 байта, `double` - 8 байт и т.д.).

Так как само имя массива есть адрес его нулевого элемента, то оператор `у = &a[0];` можно записать и в другом виде: `у = а`. Тогда элемент `а[1]` можно представить как `*(а+1)`. С другой стороны, если `у` - указатель на массив `a`, то следующие две записи: `a[i]` и `*(у+i)` - эквивалентны.

Между именем массива и соответствующим указателем есть одно важное различие. Указатель - это переменная и `у = а;` или `y++;` - допустимые операции. Имя же массива - константа, поэтому конструкции вида `a = y;` `a++;` использовать нельзя, так как значение константы постоянно и не может быть изменено.

Переменные с адресами могут образовывать некоторую иерархическую структуру (могут быть многоуровневыми) типа указатель на указатель (т.е. значение указателя является адресом другого указателя), указатель на указатель на указатель и т.д. Если указатели адресуют элементы одного массива, то их можно сравнивать (отношения вида `<`, `>`, `==`, `!=` и другие работают правильно). В то же время нельзя сравнивать ли6о использовать в арифметических операциях указатели на разные массивы (соответствующие выражения не приводят к ошибкам при компиляции, но в большинстве случаев не имеют смысла). Любой адрес можно проверить на равенство или неравенство с константой `NULL`. Указатели на элементы одного массива можно также вычитать. Тогда результатом будет число элементов массива, расположенных между уменьшаемым и вычитаемым объектами.

Язык Си позволяет инициализировать массив при его определении. Для этого используется следующая форма:

```c
тип имя_массива[...] ... [...] = {список значений};
```

Примеры:

```c
int a[5] = {0, 1, 2, 3, 4};
char ch[3] = {'d', 'e', '9'};
int b[2][3] = {1, 2, 3, 4, 5, 6};
```

В последнем случае: `b[0][0] = 1`, `b[0][1] = 2`, `b[0][2] = 3`, `b[1][0] = 4`, `b[1][1] = 5`, `b[1][2] = 6`\.

В языке допускаются массивы указателей, которые определяются, например, следующим образом: `char *m[5];`. Здесь `m[5]` - массив, содержащий адреса элементов типа `char`.
