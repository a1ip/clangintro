###Строки символов

Язык Си не поддерживает отдельный строковый тип данных, но он позволяет определить строки двумя различными способами. В первом используется массив символов, а во втором - указатель на первый символ массива.

Определение `char а[10];` указывает компилятору на необходимость резервирования места для максимум 10 символов. Константа `а` содержит адрес ячейки памяти, в которой помещено значение первого из десяти объектов типа `char`. Процедуры, связанные с занесением конкретной строки в массив `а`, копируют ее по одному символу в область памяти, на которую указывает константа `а`, до тех пор, пока не будет скопирован нулевой символ, оканчивающий строку. Когда выполняется функция типа `printf("%s", а)`, ей передается значение `а`, т.е. адрес первого символа, на который указывает `а`. Если первый символ - нулевой, то работа функции `printf()` заканчивается, а если нет, то она выводит его на экран, прибавляет к адресу единицу и снова начинает проверку на нулевой символ. Такая обработка позволяет снять ограничения на длину строки (конечно, в пределах объявленной размерности): строка может иметь любую длину, но в пределах доступной памяти.

Инициализировать строку при таком способе определения можно следующим образом:

```c
char array[7] = "Строка";
char s[ ] = {'С', 'т', 'р', 'о', 'к', 'а', '\0'};
```

(при определении массива с одновременной инициализацией пределы изменения индекса можно не указывать).

Второй способ определения строки - это использование указателя на символ. Определение `char *b;` задает переменную `b`, которая может содержать адрес некоторого объекта. Однако в данном случае компилятор не резервирует место для хранения символов и не инициализирует переменную `b` конкретным значением. Когда компилятор встречает оператор вида `b ="IBM PC";`, он производит следующие действия. Во-первых, как и в предыдущем случае, он создает в каком-либо месте объектного модуля строку `"IBM PC"`, за которой следует нулевой символ (`'\0'`). Во-вторых, он присваивает значение начального адреса этой строки (адрес символа `'I'`) переменной `b`. Функция `printf("%s", b)` работает так же, как и в предыдущем случае, осуществляя вывод символов до тех пор, пока не встретится заключительный нуль.

Массив указателей можно инициализировать, т.е. назначать его элементам конкретные адреса некоторых заданных строк при определении.

Для ввода и вывода строк символов помимо `scanf( )` и `printf()` могут использоваться функции `gets( )` и `puts( )` (их прототипы находятся в файле `stdio.h`).

Если `string` - массив символов, то ввести строку с клавиатуры можно так:

```c
gets(string);
```

(ввод оканчивается нажатием клавиши `<Enter>`). Вывести строку на экран можно следующим образом:

```c
puts(string);
```

Отметим также, что для работы со строками существует специальная библиотека функций, прототипы которых находятся в файле `string.h`.

Наиболее часто используются функции `strcpy( )`, `strcat( )`, `strlen( )` и `strcmp( )`.

Если `string1` и `string2` - массивы символов, то вызов функции `strcpy( )` имеет вид:

```c
strcpy(string1, string2);
```

Эта функция служит для копирования содержимого строки `string2` в строку `string1`\. Массив `string1` должен быть достаточно большим, чтобы в него поместилась строка `string2`\. Так как компилятор не отслеживает этой ситуации, то недостаток места приведет к потере данных.

Вызов функции `strcat( )` имеет вид:

```c
strcat(string1, string2);
```

Эта функция присоединяет строку `string2` к строке `string1` и помещает ее в массив, где находилась строка `string1`, при этом строка `string2` не изменяется. Нулевой байт, который завершал первую строку, заменяется первым байтом второй строки.

Функция `strlen( )` возвращает длину строки, при этом завершающий нулевой байт не учитывается. Если `a` - целое, то вызов функции имеет вид:

```c
a = strlen(string);
```

Функция `strcmp( )` сравнивает две строки и возвращает `0`, если они равны.